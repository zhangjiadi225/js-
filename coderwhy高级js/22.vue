//!key的作用
vue是通过虚拟dom来表示描述真实dom的，在去更新视图之前，要对前后两个虚拟dom树进行分析，以得出它们的区别。如果不设置key，Vue 会使用一种最大限度减少动态元素并且尽可能的尝试就地修改/复用相同类型元素的算法。而使用 key 时，它会基于 key 的变化重新排列元素顺序，并且会移除 key 不存在的元素。

- key的作用主要是为了更高效的对比虚拟dom中的某个节点是不是相同节点，是用来提高diff算法的性能表现。更具体一点，vue在patch过程（执行diff的算法，可翻译为打补丁算法）中判断两个节点是否是相同节点，key值相同是一个必要条件。

- key会提升效率。某些特殊情况下，不写key会出错。
- 在使用v-for循环时，尽量避免直接使用数组的下标为key，因为它们在做删除操作时可能会导致渲染异常。
- 最好是将key设成数据项中的主键：可以把一项与另一项区别开的值。

//!Vue的优点？Vue的缺点？
优点：渐进式，组件式，轻量级，虚拟dom,响应式，单页面路由，数据与视图分开。

缺点：单页面不利于SEO，不支持IE8一下，首屏加载时间长。

//!使用过哪些Vue的修饰符呢？
.lazy: 作用是改变输入框的值时value不会改变，当光标离开输入时，v-model绑定的值value才会改变。
.trim：作用类似于JS中的trim()方法，把v-model绑定的值的首位空格去掉
.number：作用是将值转换为数字
.stop：作用是阻止冒泡
.capture：事件默认由里往外冒泡，capture修饰符作用是反过来，由外往里
.self：作用是，只有点击事件绑定本身才会触发事件
.once：作用是事件只执行一次
.prevent：作用是阻止默认事件（如a标签的跳转）
.native：加在自定义组件事件上，保证事件能执行


//!Vue-Route的导航流程
1. 导航被触发。
2. 在失活的组件里调用 `beforeRouteLeave` 守卫。
3. 调用全局的 `beforeEach` 守卫。
4. 在重用的组件里调用 `beforeRouteUpdate` 守卫 (2.2+)。
5. 在路由配置里调用 `beforeEnter`。
6. 解析异步路由组件。
7. 在被激活的组件里调用 `beforeRouteEnter`。
8. 调用全局的 `beforeResolve` 守卫 (2.5+)。
9. 导航被确认。
10. 调用全局的 `afterEach` 钩子。
11. 触发 DOM 更新。
12. 调用 `beforeRouteEnter` 守卫中传给 `next` 的回调函数，创建好的组件实例会作为回调函数的参数传入。

//!token失效处理
(后端会给一个refresh的接口，当token失效时会在响应拦截里面判断，如果是因为token失效的问题报错，并且当前vuex中存在用户信息，那就会通过这个接口重新请求一个token)


//!sass和less的区别
Less和Sass的主要不同就是他们的实现方式。
Less是基于JavaScript，是在客户端处理的。
Sass是基于Ruby的，是在服务器端处理的。
关于变量在Less和Sass中的唯一区别就是Less用@，Sass用$。